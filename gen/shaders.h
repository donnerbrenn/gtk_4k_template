// Generated with Shader Minifier 1.3.5 (https://github.com/laurentlb/Shader_Minifier/)
#ifndef SHADERS_H_
# define SHADERS_H_

const char *vshader_vert =
 "#version 400\n"
 "void main()"
 "{"
   "gl_Position=vec4(gl_VertexID%2*2-1,gl_VertexID/2*2-1,1,1);"
 "}";

const char *shader_frag =
 "#version 400\n\n"
 "#define threshold.01\n"
 "#define SAMPLES 500\n"
 "#define BOUNCES 8\n"
 "float c_pi=acos(-1);"
 "out vec4 fragColor;"
 "uint state=uint(gl_FragCoord.x*gl_FragCoord.y)*uint(668265261);"
 "vec3 attentuation=vec3(1),albedo;"
 "uint wang_hash(inout uint seed)"
 "{"
   "seed^=61^(seed>>16)*9;"
   "seed^=(seed>>4)*668265261;"
   "seed^=seed>>15;"
   "return seed;"
 "}"
 "vec3 RandomUnitVector(inout uint state)"
 "{"
   "float z=wang_hash(state)/4294967296.*2.f-1.f,a=wang_hash(state)/4294967296.*(c_pi*2),r=sqrt(1.f-z*z);"
   "return vec3(r*cos(a),r*sin(a),z);"
 "}"
 "float fSphere(vec3 p,float r)"
 "{"
   "return length(p)-r;"
 "}"
 "float vmax(vec3 v)"
 "{"
   "return max(max(v.x,v.y),v.z);"
 "}"
 "float fBox(vec3 p,vec3 b)"
 "{"
   "vec3 d=abs(p)-b;"
   "return length(max(d,vec3(0)))+vmax(min(d,vec3(0)));"
 "}"
 "float scene(vec3 p)"
 "{"
   "albedo=vec3(1);"
   "float box=-fBox(p+vec3(0,0,3.5),vec3(1.5,1.5,5))+.1,ball=fSphere(p,1),ball2=fSphere(p+vec3(.8),.4),ball3=fSphere(p+vec3(-.8,.8,.8),.4),ball4=fSphere(p+vec3(-.8,-.8,.8),.4),ball5=fSphere(p+vec3(.8,-.8,.8),.4),final=min(min(min(min(min(box,ball),ball2),ball3),ball4),ball5);"
   "if(final==ball)"
     "albedo=vec3(1);"
   "if(final==ball4)"
     "albedo=vec3(.1,.9,.1);"
   "if(final==ball2)"
     "albedo=vec3(.1,.1,.9);"
   "if(final==ball3)"
     "albedo=vec3(.9,.1,.1);"
   "if(final==ball5)"
     "albedo=vec3(.05);"
   "return final;"
 "}"
 "vec3 normal(vec3 p)"
 "{"
   "mat3 k=mat3(p,p,p)-mat3(5e-4);"
   "return normalize(scene(p)-vec3(scene(k[0]),scene(k[1]),scene(k[2])));"
 "}"
 "bool march(inout vec3 p,vec3 dir)"
 "{"
   "float dst=.1;"
   "for(uint cnt=0;cnt<256&&dst>threshold;cnt++)"
     "p+=dir*dst,dst=scene(p);"
   "return dst<threshold;"
 "}"
 "vec3 calcLight(vec3 d,vec3 n,vec3 color,float power)"
 "{"
   "float light=max(dot(n,-normalize(d)),0);"
   "vec3 diffuse=albedo*attentuation*light*power;"
   "return(color*diffuse+pow(light,32))*power;"
 "}"
 "void main()"
 "{"
   "vec2 uv=(gl_FragCoord.xy/vec2(2560,1440)*2-1)/vec2(1,2560./1440.);"
   "fragColor.xyz=vec3(0);"
   "vec3 n;"
   "float cameraDistance=1.f/tan(60*.5f*c_pi/180.f);"
   "for(int j=0;j<SAMPLES;j++)"
     "{"
       "vec3 d=normalize(vec3(uv,cameraDistance)),ro=vec3(0,0,-5);"
       "attentuation=vec3(1);"
       "for(int i=0;i<BOUNCES&&march(ro,d);i++)"
         "n=normal(ro),fragColor.xyz+=calcLight(ro-vec3(0,6,-6),n,vec3(1),.5),fragColor.xyz+=calcLight(vec3(1,-1,.1),n,vec3(1),.5),fragColor.xyz+=calcLight(vec3(-1,-1,.1),n,vec3(.5,1,.125),1),fragColor.xyz+=calcLight(RandomUnitVector(state),n,vec3(.5,.5,1),.5),d=normalize(n+RandomUnitVector(state)),attentuation*=albedo*max(dot(d,n),0),fragColor.w++;"
     "}"
   "fragColor.xyz=sqrt(fragColor.xyz/fragColor.w);"
 "}";

#endif // SHADERS_H_
