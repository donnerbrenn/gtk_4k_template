// Generated with Shader Minifier 1.3.5 (https://github.com/laurentlb/Shader_Minifier/)
#ifndef SHADERS_H_
# define SHADERS_H_

const char *vshader_vert =
 "#version 400\n"
 "void main()"
 "{"
   "gl_Position=vec4(gl_VertexID%2*2-1,gl_VertexID/2*2-1,1,1);"
 "}";

const char *shader_frag =
 "#version 400\n"
 "uint m=uint(gl_FragCoord.x*gl_FragCoord.y)*uint(668265261);"
 "out vec4 Frag;"
 "vec3 v=vec3(1),f;"
 "float F,r,s;"
 "vec3 n(vec3 v,vec3 m)"
 "{"
   "float f=cos(m.x),r=sin(m.x);"
   "mat3 F=mat3(vec3(1,0,0),vec3(0,f,-r),vec3(0,r,f));"
   "f=cos(m.y);"
   "r=sin(m.y);"
   "F*=mat3(vec3(f,0,r),vec3(0,1,0),vec3(-r,0,f));"
   "f=cos(m.z);"
   "r=sin(m.z);"
   "F*=mat3(vec3(f,-r,0),vec3(r,f,0),vec3(0,0,1));"
   "return F*v;"
 "}"
 "float n(float m,float v,float d)"
 "{"
   "return min(m,v)-pow(max(d-abs(m-v),0.),2)*.25/d;"
 "}"
 "float n(vec3 v,float f,float m,float d,float y)"
 "{"
   "vec2 r=vec2(length(v.xz),v.y),F=vec2(d,f),x=vec2(d-m,2.*f),g=vec2(r.x-min(r.x,r.y<0.?"
     "m:"
     "d),abs(r.y)-f),z=r-F+x*clamp(dot(F-r,x)/dot(x,x),0.,1.);"
   "return z.x<0.&&g.y<0.?"
     "-1.:"
     "sqrt(min(dot(g,g),dot(z,z)))-y;"
 "}"
 "float n(inout uint m)"
 "{"
   "m^=61^(m>>16)*9^(m>>4)*668265261^m>>15;"
   "return m/4294967296.;"
 "}"
 "vec3 t(inout uint m)"
 "{"
   "float v=n(m)*2-1,f=acos(-1)*2*n(m),r=sqrt(1-v*v);"
   "return vec3(r*cos(f),r*sin(f),v);"
 "}"
 "float x(vec3 m)"
 "{"
   "return max(max(m.x,m.y),m.z);"
 "}"
 "float t(vec3 m,vec3 v)"
 "{"
   "vec3 f=abs(m)-v;"
   "return length(max(f,vec3(0)))+x(min(f,vec3(0)));"
 "}"
 "float d(vec3 m)"
 "{"
   "m=n(n(m,vec3(-.7,0,-.04)),vec3(0,1.1,0));"
   "m.y-=1.05;"
   "m.x+=.5;"
   "f=vec3(0);"
   "F=.3;"
   "r=64;"
   "s=0;"
   "vec2 v=fract(m.xz*vec2(233.34,851.74));"
   "v+=dot(v,v+23.45);"
   "float d=t(mod(m,1e-4)-5e-5,vec3(0))-fract(v.x*v.y)*.001,z=mix(dot(m,vec3(0,1,0))+2.2,d,.01),g=min(min(min(min(n(length(m+vec3(0,-1,0))-.5,n(m+vec3(0,.1,0),1.,.15,.25,0),.05),min(n(m+vec3(1.75,1.27,-.75),.05,.4,.4,.015),n(m+vec3(1.75,1.27,.75),.05,.4,.4,.015))-.01),min(n(m+vec3(1.75,1.34,.75),.05,.55,.45,.02),n(m+vec3(1.75,1.34,-.75),.05,.55,.45,.02))-.005),min(n(n(n(n(m+vec3(0,.6,0),.05,.3,.3,.05),n(m+vec3(0,1,0),.3,.6,.6,.05),.15),t(m+vec3(0,1.4,0),vec3(.9,.15,.9))-.1,.15),mix(t(m+vec3(.5,1.85,0),vec3(1.55,0,1.05))-.45,d,.005),.15),t(m+vec3(10,sin(m.x*1.8)*.1+2.05,sin(m.x*0.+sin(m.x*.7))+.75),vec3(8,0,0))-.1)),z);"
   "if(g==min(min(n(length(m+vec3(0,-1,0))-.5,n(m+vec3(0,.1,0),1.,.15,.25,0),.05),min(n(m+vec3(1.75,1.27,-.75),.05,.4,.4,.015),n(m+vec3(1.75,1.27,.75),.05,.4,.4,.015))-.01),min(n(m+vec3(1.75,1.34,.75),.05,.55,.45,.02),n(m+vec3(1.75,1.34,-.75),.05,.55,.45,.02))-.005))"
     "f=vec3(.8,.01,.01),r=256;"
   "if(g==z)"
     "f=vec3(.03),r=64,F=.1;"
   "return g;"
 "}"
 "vec3 e(vec3 m)"
 "{"
   "mat3 v=mat3(m,m,m)-mat3(5e-5);"
   "return normalize(d(m)-vec3(d(v[0]),d(v[1]),d(v[2])));"
 "}"
 "bool d(inout vec3 m,vec3 v)"
 "{"
   "float f=.1,r=0;"
   "for(;r<100&&f>.001;r+=f)"
     "m+=v*f,f=d(m);"
   "return f<.001;"
 "}"
 "vec3 d(vec3 m,vec3 d,vec3 z,float y)"
 "{"
   "float g=max(dot(d,normalize(m)),0);"
   "return(f*v*g*z+pow(g,r)*F)*y;"
 "}"
 "void main()"
 "{"
   "vec3[3] r;"
   "r[0]=vec3(0,10,-20);"
   "r[1]=vec3(-50,20,-50);"
   "r[2]=vec3(50,20,-50);"
   "vec2 g=(gl_FragCoord.xy/vec2(2560,1440)*2-1)/vec2(1,2560./1440.);"
   "Frag.xyz=vec3(0);"
   "vec3 z,F,x;"
   "for(int y=0;y<300;y++)"
     "{"
       "x=normalize(vec3(g,1.f/tan(85*.5f*acos(-1)/180.f)));"
       "F=vec3(g,-5);"
       "v=vec3(.5,.5,1);"
       "for(int n=0;n<8&&d(F,x);n++)"
         "z=e(F),Frag.xyz+=s,Frag.xyz+=d(r[0],z,vec3(.5,.5,.9),.5),Frag.xyz+=d(r[1],z,vec3(1,.1,.1),.5),Frag.xyz+=d(r[2],z,vec3(.5,1,.125),.8),Frag.xyz+=d(t(m),z,vec3(0,0,1),.25),x=normalize(z+t(m)),v*=f*max(dot(x,z),0),Frag.w++;"
       "Frag.xyz+=Frag.w==0?"
         "vec3(0):"
         "v;"
     "}"
   "Frag.xyz=sqrt(Frag.xyz/Frag.w);"
 "}";

#endif // SHADERS_H_
