// Generated with Shader Minifier 1.3.5 (https://github.com/laurentlb/Shader_Minifier/)
#ifndef SHADERS_H_
# define SHADERS_H_

const char *vshader_vert =
 "#version 400\n"
 "void main()"
 "{"
   "gl_Position=vec4(gl_VertexID%2*2-1,gl_VertexID/2*2-1,1,1);"
 "}";

const char *shader_frag =
 "#version 400\n"
 "uint v=uint(gl_FragCoord.x*gl_FragCoord.y)*uint(668265261);"
 "out vec4 Frag;"
 "vec3 f,m;"
 "float y,r,z,F;"
 "vec3 n(vec3 y,vec3 v)"
 "{"
   "vec3 m=cos(v),f=sin(v);"
   "return mat3(m.z,-f.z,0,f.z,m.z,0,0,0,1)*mat3(m.y,0,f.y,0,1,0,-f.y,0,m.y)*mat3(1,0,0,0,m.x,-f.x,0,f.x,m.x)*y;"
 "}"
 "float n(float v,float f,float m)"
 "{"
   "return min(v,f)-pow(max(m-abs(v-f),0.),2)*.25/m;"
 "}"
 "float n(vec3 v,float f,float y,float m,float F)"
 "{"
   "vec2 g=vec2(length(v.xz),v.y),d=vec2(m,f),z=vec2(m-y,2.*f),r=vec2(g.x-min(g.x,g.y<0.?"
     "y:"
     "m),abs(g.y)-f),s=g-d+z*clamp(dot(d-g,z)/dot(z,z),0.,1.);"
   "return s.x<0.&&r.y<0.?"
     "-1.:"
     "sqrt(min(dot(r,r),dot(s,s)))-F;"
 "}"
 "float n(inout uint v)"
 "{"
   "v^=61^(v>>16)*9^(v>>4)*668265261^v>>15;"
   "return v/4294967296.;"
 "}"
 "vec3 t(inout uint v)"
 "{"
   "float f=n(v)*2-1,m=acos(-1)*2*n(v),z=sqrt(1-f*f);"
   "return vec3(z*cos(m),z*sin(m),f);"
 "}"
 "float t(vec3 v,vec3 f)"
 "{"
   "vec3 m=abs(v)-f;"
   "return length(max(m,0.))+min(0.,max(m.x,max(m.y,m.z)));"
 "}"
 "float s(vec3 v)"
 "{"
   "v=n(n(v,vec3(-.7,0,-.04)),vec3(0,1.1,0))+vec3(.5,-1.05,0);"
   "m=vec3(.03);"
   "y=.3;"
   "r=64;"
   "z=0;"
   "F=.2;"
   "vec2 f=fract(v.xz*vec2(233.34,851.74));"
   "f+=dot(f,f+23.45);"
   "float s=t(mod(v,1e-4)-5e-5,vec3(0))-fract(f.x*f.y)*.02,a=mix(dot(v,vec3(0,1,0))+2.2,s,.005),g=min(min(n(t(v+vec3(0,-1,0),vec3(0))-.5,n(v+vec3(0,.1,0),1,.15,.25,0),.025),n(vec3(v.xy,abs(v.z))+vec3(1.75,1.27,-.75),.05,.4,.4,.015)-.01),n(vec3(v.xy,abs(v.z))+vec3(1.75,1.34,-.75),.05,.55,.45,.02)-.005),d=min(n(n(n(n(v+vec3(0,.6,0),.05,.3,.3,.05),n(v+vec3(0,1,0),.3,.6,.6,.05),.05),t(v+vec3(0,1.4,0),vec3(.9,.15,.9))-.1,.15),mix(t(v+vec3(.5,1.85,0),vec3(1.55,0,1.05))-.45,s,.01),.05),t(v+vec3(15.5,sin(v.x*1.8)*.1+2.05,sin(v.x*0.+sin(v.x*.7))+.75),vec3(15,0,0))-.1),u=min(min(g,d),a);"
   "m=u==a?"
     "vec3(.05):"
     "u==g?"
       "vec3(.7,.01,.01):"
       "m;"
   "F=u==a?"
     "1:"
     "u==g?"
       ".4:"
       "u==d?"
         ".95:"
         "F;"
   "y=u==a?"
     ".1:"
     "u==d?"
       ".2:"
       "y;"
   "return u;"
 "}"
 "vec3 x(vec3 v)"
 "{"
   "mat3 m=mat3(v,v,v)-mat3(.001);"
   "return normalize(s(v)-vec3(s(m[0]),s(m[1]),s(m[2])));"
 "}"
 "bool s(inout vec3 v,vec3 m)"
 "{"
   "float f=.1,r=0;"
   "for(;r<25&&f>.01;r+=f)"
     "v+=m*f,f=s(v);"
   "return f<.01;"
 "}"
 "vec3 n(vec3 v,vec3 g,vec3 z,float F)"
 "{"
   "float s=max(dot(g,normalize(v)),0);"
   "return(m*f*s*z+pow(s,r)*y)*F;"
 "}"
 "void main()"
 "{"
   "vec2 g=(gl_FragCoord.xy/vec2(2560,1440)*2-1)/vec2(1,2560./1440.);"
   "Frag.xyz=vec3(0);"
   "vec3 y,r,d;"
   "for(int u=0;u<300;u++)"
     "{"
       "d=normalize(vec3(g,1.f/tan(85*.5f*acos(-1)/180.f)));"
       "r=vec3(g,-5);"
       "f=vec3(.5,.5,1);"
       "for(int w=0;w<32&&s(r,d);w++)"
         "y=x(r),f+=m*z,Frag.xyz+=n(vec3(0,10,-20),y,vec3(.5,.5,.9),.5)+n(vec3(-50,20,-50),y,vec3(1,.1,.1),.5)+n(vec3(50,20,-50),y,vec3(.5,1,.125),.8)+n(t(v),y,vec3(0,0,1),.25),d=normalize(mix(normalize(y+t(v)),reflect(d,y),F)),f*=m*max(dot(d,y),0),Frag.w++;"
       "Frag.xyz+=Frag.w==0?"
         "vec3(0):"
         "f;"
     "}"
   "Frag.xyz=sqrt(Frag.xyz/Frag.w);"
 "}";

#endif // SHADERS_H_
