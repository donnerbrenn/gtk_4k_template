// Generated with Shader Minifier 1.3.6 (https://github.com/laurentlb/Shader_Minifier/)
#ifndef SHADERS_H_
# define SHADERS_H_
# define VAR_Frag "m"

const char *vshader_vert =
 "#version 400\n"
 "void main()"
 "{"
   "gl_Position=vec4(gl_VertexID%2*2-1,gl_VertexID/2*2-1,1,1);"
 "}";

const char *shader_frag =
 "#version 400\n"
 "uint v=uint(gl_FragCoord.x*gl_FragCoord.y)*uint(668265261);"
 "out vec4 m;"
 "struct MA{vec3 abd;float spc;float shp;float ems;float mtl;} f;"
 "vec3 s;"
 "vec3 n(vec3 s,vec3 v)"
 "{"
   "vec3 m=cos(v),f=sin(v);"
   "return mat3(m.z,-f.z,0,f.z,m.z,0,0,0,1)*mat3(m.y,0,f.y,0,1,0,-f.y,0,m.y)*mat3(1,0,0,0,m.x,-f.x,0,f.x,m.x)*s;"
 "}"
 "float n(float v,float f,float m)"
 "{"
   "return min(v,f)-pow(max(m-abs(v-f),0),2)*.25/m;"
 "}"
 "float n(vec3 v,float f,float m,float y,float s)"
 "{"
   "vec2 d=vec2(length(v.xz),v.y),x=vec2(y-m,2*f),z=vec2(d.x-min(d.x,d.y<0.?"
     "m:"
     "y),abs(d.y)-f),i=d-vec2(y,f)+x*clamp(dot(vec2(y,f)-d,x)/dot(x,x),0.,1.);"
   "return(i.x<0.&&z.y<0.?"
     "-1.:"
     "1.)*sqrt(min(dot(z,z),dot(i,i)))-s;"
 "}"
 "float n(inout uint v)"
 "{"
   "v^=61^(v>>16)*9^(v>>4)*668265261^v>>15;"
   "return float(v)/4294967296.;"
 "}"
 "vec3 t(inout uint v)"
 "{"
   "float f=n(v)*2-1,m=acos(-1)*2*n(v),d=sqrt(1-f*f);"
   "return vec3(d*cos(m),d*sin(m),f);"
 "}"
 "float t(vec3 v,vec3 f)"
 "{"
   "vec3 m=abs(v)-f;"
   "return length(max(m,0.))+min(0.,max(m.x,max(m.y,m.z)));"
 "}"
 "float d(vec3 v)"
 "{"
   "v=n(n(v,vec3(-.7,0,-.04)),vec3(0,1.1,0))+vec3(.5,-1.05,0);"
   "vec2 m=fract(v.xz*vec2(233.34,851.74));"
   "m+=dot(m,m+23.45);"
   "float s=t(mod(v,1e-4)-5e-5,vec3(0))-fract(m.x*m.y)*.02,d=dot(v,vec3(0,1,0))+2.2,x=min(min(n(t(v+vec3(0,-1,0),vec3(0))-.5,n(v+vec3(0,.3,0),1,.15,.25,0),.025),n(vec3(v.xy,abs(v.z))+vec3(1.75,1.27,-.75),.05,.4,.4,.015)-.01),n(vec3(v.xy,abs(v.z))+vec3(1.75,1.34,-.75),.05,.55,.45,.02)-.005),z=min(n(n(n(n(v+vec3(0,.6,0),.05,.3,.3,.05),n(v+vec3(0,1,0),.3,.6,.6,.05),.05),t(v+vec3(0,1.4,0),vec3(.9,.15,.9))-.1,.1),mix(t(v+vec3(.5,1.85,0),vec3(1.55,0,1.05))-.45,s,.01),.1),t(v+vec3(15.5,sin(v.x*1.8)*.1+2.05,sin(v.x*0.+sin(v.x*.7))+.75),vec3(15,0,0))-.1),y=t(v+vec3(0,-8,0),vec3(4,.1,4));"
   "s=min(min(min(x,z),d),y);"
   "f=s==x?"
     "MA(vec3(.6,.002,.002),.6,64,0,0):"
     "s==d?"
       "MA(vec3(.1),.5,64,0,.25):"
       "s==z?"
         "MA(vec3(.02),.5,64,0,.8):"
         "f;"
   "return s;"
 "}"
 "vec3 x(vec3 v)"
 "{"
   "mat3 m=mat3(v,v,v)-mat3(.001);"
   "return normalize(d(v)-vec3(d(m[0]),d(m[1]),d(m[2])));"
 "}"
 "bool d(inout vec3 v,vec3 m)"
 "{"
   "float f=.1,s=0;"
   "for(;s<100&&f>.003;s+=f)"
     "v+=m*f,f=d(v);"
   "return f<.003;"
 "}"
 "vec3 d(vec3 v,vec3 m,vec3 y,float z)"
 "{"
   "float d=max(dot(m,normalize(v)),0);"
   "return(f.abd*s*d*y+pow(d,f.shp)*f.spc)*z;"
 "}"
 "void main()"
 "{"
   "vec2 y=(gl_FragCoord.xy/vec2(2560,1440)*2-1)/vec2(1,2560./1440.);"
   "m.xyz=vec3(0);"
   "vec3 z,i,r;"
   "for(int n=0;n<300;n++)"
     "{"
       "r=normalize(vec3(y,1.f/tan(90*.5f*acos(-1)/180.f)));"
       "i=vec3(y,-5);"
       "s=vec3(.5,.5,1);"
       "for(int u=0;u<5&&d(i,r);u++)"
         "{"
           "z=x(i);"
           "vec3 a=s*f.ems;"
           "a+=a*pow(max(dot(r,z),0),f.shp)*f.spc*f.ems;"
           "m.xyz+=a*3;"
           "m.xyz+=d(vec3(50,-30,-30),z,vec3(.25,.25,.9),.25)+d(vec3(0,20,-50),z,vec3(1),1);"
           "r=normalize(mix(normalize(z+t(v)),reflect(r,z),f.mtl));"
           "s*=f.abd;"
           "m.w++;"
         "}"
       "m.xyz+=m.w==0?"
         "vec3(0):"
         "s;"
     "}"
   "m.xyz=sqrt(m.xyz/m.w);"
 "}";

#endif // SHADERS_H_
