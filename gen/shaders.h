// Generated with Shader Minifier 1.3.6 (https://github.com/laurentlb/Shader_Minifier/)
#ifndef SHADERS_H_
# define SHADERS_H_
# define VAR_Frag "f"

const char *vshader_vert =
 "#version 400\n"
 "void main()"
 "{"
   "gl_Position=vec4(gl_VertexID%2*2-1,gl_VertexID/2*2-1,1,1);"
 "}";

const char *shader_frag =
 "#version 400\n"
 "float m=acos(-1);"
 "uint v=uint(gl_FragCoord.x*gl_FragCoord.y)*uint(668265261);"
 "out vec4 f;"
 "struct MA{vec3 abd;float spc;float shp;float ems;float mtl;} s;"
 "MA n=MA(vec3(.1),.5,64,0,0),a=MA(vec3(.6,0,0),.5,64,0,.1),z=MA(vec3(.02),.5,64,0,.9);"
 "vec3 r;"
 "vec3 t(vec3 s,vec3 v)"
 "{"
   "vec3 f=cos(v),a=sin(v);"
   "return mat3(f.z,-a.z,0,a.z,f.z,0,0,0,1)*mat3(f.y,0,a.y,0,1,0,-a.y,0,f.y)*mat3(1,0,0,0,f.x,-a.x,0,a.x,f.x)*s;"
 "}"
 "float t(float v,float f,float m)"
 "{"
   "return min(v,f)-pow(max(m-abs(v-f),0),2)*.25/m;"
 "}"
 "float t(vec3 v,float f,float m,float y,float s)"
 "{"
   "vec2 a=vec2(length(v.xz),v.y),d=vec2(y,f),z=vec2(y-m,2*f),x=vec2(a.x-min(a.x,a.y<0.?"
     "m:"
     "y),abs(a.y)-f),n=a-d+z*clamp(dot(d-a,z)/dot(z,z),0.,1.);"
   "return n.x<0&&x.y<0?"
     "-1:"
     "sqrt(min(dot(x,x),dot(n,n)))-s;"
 "}"
 "float t(inout uint v)"
 "{"
   "v^=61^(v>>16)*9^(v>>4)*668265261^v>>15;"
   "return float(v)/4294967296.;"
 "}"
 "vec3 x(inout uint v)"
 "{"
   "float f=t(v)*2-1,a=m*2*t(v),d=sqrt(1-f*f);"
   "return vec3(d*cos(a),d*sin(a),f);"
 "}"
 "float x(vec3 v,vec3 f)"
 "{"
   "vec3 a=abs(v)-f;"
   "return length(max(a,0.))+min(0.,max(a.x,max(a.y,a.z)));"
 "}"
 "float d(vec3 v)"
 "{"
   "v=t(t(v,vec3(-.7,0,-.04)),vec3(0,1.1,0))+vec3(.5,-1.05,0);"
   "vec2 f=fract(v.xz*vec2(233.34,851.74));"
   "f+=dot(f,f+23.45);"
   "float m=x(mod(v,1e-4)-5e-5,vec3(0))-fract(f.x*f.y)*.02,d=dot(v,vec3(0,1,0))+2.2,y=min(min(t(x(v+vec3(0,-1,0),vec3(0))-.5,t(v+vec3(0,.3,0),1,.15,.25,0),.025),t(vec3(v.xy,abs(v.z))+vec3(1.75,1.27,-.75),.05,.4,.4,.015)-.01),t(vec3(v.xy,abs(v.z))+vec3(1.75,1.34,-.75),.05,.55,.45,.02)-.005),M=min(t(t(t(t(v+vec3(0,.6,0),.05,.3,.3,.05),t(v+vec3(0,1,0),.3,.6,.6,.05),.05),x(v+vec3(0,1.4,0),vec3(.9,.15,.9))-.1,.1),mix(x(v+vec3(.5,1.85,0),vec3(1.55,0,1.05))-.45,m,.01),.05),x(v+vec3(15.5,sin(v.x*1.8)*.1+2.05,sin(v.x*0.+sin(v.x*.7))+.75),vec3(15,0,0))-.1),p=x(v+vec3(0,-8,0),vec3(4,.1,4));"
   "m=min(min(min(y,M),d),p);"
   "s=m==y?"
     "a:"
     "m==d?"
       "n:"
       "m==M?"
         "z:"
         "s;"
   "return m;"
 "}"
 "vec3 e(vec3 v)"
 "{"
   "mat3 m=mat3(v,v,v)-mat3(.001);"
   "return normalize(d(v)-vec3(d(m[0]),d(m[1]),d(m[2])));"
 "}"
 "bool d(inout vec3 v,vec3 f)"
 "{"
   "float m=.1,a=0;"
   "for(;a<100&&m>.01;a+=m)"
     "v+=f*m,m=d(v);"
   "return m<.01;"
 "}"
 "vec3 d(vec3 v,vec3 m,vec3 f,float y)"
 "{"
   "float a=max(dot(m,normalize(v)),0);"
   "return(s.abd*r*a*f+pow(a,s.shp)*s.spc)*y;"
 "}"
 "void main()"
 "{"
   "vec2 a=(gl_FragCoord.xy/vec2(2560,1440)*2-1)/vec2(1,2560./1440.);"
   "f.xyz=vec3(0);"
   "vec3 y,z,n;"
   "for(int M=0;M<800;M++)"
     "{"
       "n=normalize(vec3(a,1.f/tan(90*.5f*m/180.f)));"
       "z=vec3(a,-5);"
       "r=vec3(.5,.5,1);"
       "for(int u=0;u<81&&d(z,n);u++)"
         "{"
           "y=e(z);"
           "vec3 c=r*s.ems;"
           "c+=c*pow(max(dot(n,y),0),s.shp)*s.spc*s.ems;"
           "f.xyz+=c*3;"
           "f.xyz+=d(vec3(50,-30,-30),y,vec3(.25,.25,.9),.25)+d(vec3(0,20,-50),y,vec3(1),1);"
           "n=normalize(mix(normalize(y+x(v)),reflect(n,y),s.mtl));"
           "r*=s.abd;"
           "f.w++;"
         "}"
       "f.xyz+=f.w==0?"
         "vec3(0):"
         "r;"
     "}"
   "f.xyz=sqrt(f.xyz/f.w);"
 "}";

#endif // SHADERS_H_
