// Generated with Shader Minifier 1.3.5 (https://github.com/laurentlb/Shader_Minifier/)
#ifndef SHADERS_H_
# define SHADERS_H_

const char *vshader_vert =
 "#version 400\n"
 "void main()"
 "{"
   "gl_Position=vec4(gl_VertexID%2*2-1,gl_VertexID/2*2-1,1,1);"
 "}";

const char *shader_frag =
 "#version 400\n\n"
 "#define threshold.01\n"
 "#define SAMPLES 600\n"
 "#define BOUNCES 16\n"
 "float m=acos(-1)*2;"
 "out vec4 fragColor;"
 "uint v=uint(gl_FragCoord.x*gl_FragCoord.y)*uint(668265261);"
 "vec3 f=vec3(1),r;"
 "uint t(inout uint v)"
 "{"
   "v=uint(v^uint(61))^uint(v>>uint(16));"
   "v*=uint(9);"
   "v^=v>>4;"
   "v*=uint(668265261);"
   "v^=v>>15;"
   "return v;"
 "}"
 "vec3 n(inout uint v)"
 "{"
   "float f=t(v)/4294967296.*2.f-1.f,r=t(v)/4294967296.*m,i=sqrt(1.f-f*f);"
   "return vec3(i*cos(r),i*sin(r),f);"
 "}"
 "float n(vec3 v,float f)"
 "{"
   "return length(v)-f;"
 "}"
 "float x(vec3 v)"
 "{"
   "return max(max(v.x,v.y),v.z);"
 "}"
 "float t(vec3 v,vec3 f)"
 "{"
   "vec3 m=abs(v)-f;"
   "return length(max(m,vec3(0)))+x(min(m,vec3(0)));"
 "}"
 "float u(vec3 v)"
 "{"
   "r=vec3(1);"
   "float m=-t(v+vec3(0,0,3.5),vec3(1.2,1.2,5))+.1,f=n(v,1),u=n(v+vec3(.75),.3),i=n(v+vec3(-.75,.75,.75),.3),z=n(v+vec3(-.75,-.75,.75),.3),s=n(v+vec3(.75,-.75,.75),.3),d=min(min(min(min(min(m,f),u),i),z),s);"
   "if(d==f)"
     "r=vec3(.1,.5,.1);"
   "if(d==u)"
     "r=vec3(.1,.1,.9);"
   "if(d==i)"
     "r=vec3(.9,.2,.2);"
   "if(d==s)"
     "r=vec3(.05);"
   "return d;"
 "}"
 "vec3 s(vec3 v)"
 "{"
   "mat3 m=mat3(v,v,v)-mat3(5e-4);"
   "return normalize(u(v)-vec3(u(m[0]),u(m[1]),u(m[2])));"
 "}"
 "bool s(inout vec3 v,vec3 f)"
 "{"
   "float m=.1;"
   "for(uint r=0;r<256&&m>threshold;r++)"
     "v+=f*m,m=u(v);"
   "return m<threshold;"
 "}"
 "vec3 n(vec3 v,vec3 m,vec3 u,float s)"
 "{"
   "float d=max(dot(m,-normalize(v)),0);"
   "vec3 i=r*f*d*s;"
   "return u*i*(pow(d,16)*s/2);"
 "}"
 "void main()"
 "{"
   "vec2 m=(gl_FragCoord.xy/vec2(2560,1440)*2-1)/vec2(1,2560./1440.);"
   "fragColor.xyz=vec3(0);"
   "vec3 d;"
   "float u=1.f/tan(60*.5f*acos(-1)/180.f);"
   "for(int i=0;i<SAMPLES;i++)"
     "{"
       "vec3 z=normalize(vec3(m,u)),g=vec3(0,0,-5);"
       "f=vec3(1);"
       "for(int B=0;B<BOUNCES&&s(g,z);B++)"
         "{"
           "d=s(g);"
           "fragColor.xyz+=n(g-vec3(0,6,-6),d,vec3(1),2);"
           "fragColor.xyz+=n(vec3(1,-1,.1),d,vec3(.5,.5,.125),1);"
           "fragColor.xyz+=n(vec3(-1,-1,.1),d,vec3(.5,1,.125),1);"
           "fragColor.xyz+=n(z,d,vec3(.2,.2,.5),2);"
           "z=reflect(z,d);"
           "if(B==0)"
             "z=normalize(d+n(v));"
           "f*=r*max(dot(z,d),0);"
         "}"
     "}"
   "fragColor.xyz=sqrt(fragColor.xyz/(SAMPLES*sqrt(BOUNCES)));"
 "}";

#endif // SHADERS_H_
