// Generated with Shader Minifier 1.5.1 (https://github.com/laurentlb/Shader_Minifier/)
#ifndef SHADERS_H_
# define SHADERS_H_
# define VAR_color "M"

const char *vshader_vert =
 "#version 400\n"
 "void main()"
 "{"
   "gl_Position=vec4(gl_VertexID%2*2-1,gl_VertexID/2*2-1,1,1);"
 "}";

const char *shader_frag =
 "#version 400\n"
 "vec3 v=normalize(vec3((gl_FragCoord.xy/vec2(2560,1440)*2-1)*vec2(1,.5625),1)),d=vec3(0,0,-6),f[10],r[3];"
 "out vec3 M;"
 "float i=0;"
 "vec3 n(vec3 d,vec3 v)"
 "{"
   "vec3 f=cos(v);"
   "v=sin(v);"
   "return mat3(f.z,-v.z,0,v.z,f.z,0,0,0,1)*mat3(f.y,0,v.y,0,1,0,-v.y,0,f.y)*mat3(1,0,0,0,f.x,-v.x,0,v.x,f.x)*d;"
 "}"
 "struct MA{float d;vec3 col;bool hit;};"
 "MA n(vec3 v,float d,float m,float e,float M,vec3 f)"
 "{"
   "vec2 r=vec2(length(v.xz),v.y),l=vec2(e,d),x=vec2(e-m,2.*d),y=vec2(r.x-min(r.x,r.y<0.?"
     "m:"
     "e),abs(r.y)-d);"
   "r=r-l+x*clamp(dot(l-r,x)/dot(x,x),0.,1.);"
   "return MA(r.x<0.&&y.y<0.?"
     "-1.:"
     "sqrt(min(dot(y,y),dot(r,r)))-M,f,false);"
 "}"
 "MA n(vec3 v,vec3 d,float m,vec3 f)"
 "{"
   "v=abs(v)-d;"
   "return MA(length(max(v,0.))+min(max(v.x,max(v.y,v.z)),0.)-m,f,false);"
 "}"
 "MA n(MA v,MA d)"
 "{"
   "return v.d<d.d?"
     "v:"
     "d;"
 "}"
 "float n(float v,float d,float e)"
 "{"
   "return min(v,d)-pow(max(e-abs(v-d),0.),2)*.25/e;"
 "}"
 "MA n(vec3 v)"
 "{"
   "v=n(n(v,vec3(-.7,0,-.04)),vec3(0,1.1,0));"
   "v.y-=1.05;"
   "v.x+=.5;"
   "MA f=MA(dot(v+vec3(0,1.25,0),vec3(0,1,0))+1,vec3(.03),false),d=n(v+vec3(0,.1,0),1.,.15,.25,0,vec3(.2,0,0)),r=n(v+vec3(0,.6,0),.05,.3,.3,.05,vec3(-.015)),M=n(v+vec3(0,1,0),.3,.6,.6,.05,vec3(-.015)),x=n(v+vec3(0,1.4,0),vec3(.9,.15,.9),.1,vec3(-.015)),y=n(n(v+vec3(1.75,1.34,.75),.05,.55,.45,.02,vec3(.2,0,0)),n(v+vec3(1.75,1.34,-.75),.05,.55,.45,.02,vec3(.2,0,0))),e,i,z,m,l,t;"
   "y.d-=5e-4;"
   "e=n(n(v+vec3(1.75,1.27,-.75),.05,.4,.4,.015,vec3(.2,0,0)),n(v+vec3(1.75,1.27,.75),.05,.4,.4,.015,vec3(.2,0,0)));"
   "i=n(v+vec3(.5,1.85,0),vec3(1.55,0,1.05),.45,vec3(-.015));"
   "z=n(v+vec3(10,sin(v.x*1.8)*.1+2.05,sin(v.x*0.+sin(v.x*.7))+.75),vec3(8,0,0),.1,vec3(-.015));"
   "m=n(v+vec3(0,-1,0),vec3(0),.5,vec3(.2,0,0));"
   "vec2 g=fract(v.xz*vec2(233.34,851.74));"
   "g+=dot(g,g+23.45);"
   "l=n(mod(v,1e-4)-5e-5,vec3(0),fract(g.x*g.y)*.002,vec3(-.015));"
   "f.d=mix(f.d,l.d,.05);"
   "t=MA(0.,vec3(-.015),true);"
   "t.d=n(M.d,x.d,.15);"
   "t.d=n(t.d,r.d,.05);"
   "m=n(n(m,d),i);"
   "m.d=mix(m.d,l.d,.3);"
   "return n(n(n(n(n(m,t),y),e),f),z);"
 "}"
 "MA n(vec3 v,vec3 m,float e)"
 "{"
   "MA f=MA(1.,vec3(0),false);"
   "for(;i<800&&length(v-d)<e&&!f.hit;i+=1.)"
     "d+=f.d*m,f=n(d),f.hit=f.d<1e-4;"
   "return f;"
 "}"
 "vec3 t(vec3 v)"
 "{"
   "mat3 d=mat3(v,v,v)-mat3(.005);"
   "return normalize(n(v).d-vec3(n(d[0]).d,n(d[1]).d,n(d[2]).d));"
 "}"
 "float t(vec3 v,vec3 d)"
 "{"
   "float m=1.,f=0;"
   "for(float e=.1;e<20;)"
     "{"
       "float M=n(v+d*e).d,r;"
       "if(M<.001)"
         "return 0.;"
       "r=M*M/(2.*f);"
       "m=min(m,25*sqrt(M*M-r*r)/max(0.,e-r));"
       "f=M;"
       "e+=M;"
     "}"
   "return m;"
 "}"
 "vec3 n(vec3 d,vec3 m,vec3 e)"
 "{"
   "for(int M=0;M<3;M++)"
     "{"
       "float x=max(0.,dot(reflect(v,m),f[M]));"
       "e+=(x*.0333+pow(x,64)*.3)*r[M]*t(d,f[M]);"
     "}"
   "return e;"
 "}"
 "void main()"
 "{"
   "f[0]=normalize(vec3(0,10,-2));"
   "f[1]=normalize(vec3(-50,20,-50));"
   "f[2]=normalize(vec3(-50,60,-7));"
   "r[0]=vec3(.5,.5,.7)*2;"
   "r[1]=vec3(.5,.7,.5);"
   "r[2]=vec3(.7,.5,.5)*.75;"
   "MA m=n(vec3(0,0,-6),v,20);"
   "vec3 e=t(d);"
   "if(m.hit)"
     "{"
       "M=m.col;"
       "M=n(d,e,m.col);"
       "if(m.col==vec3(-.015))"
         "{"
           "d-=v*.01;"
           "v=normalize(reflect(v,e));"
           "m=n(d,v,2.5);"
           "if(m.hit)"
             "M=mix(M,n(d,t(d),m.col),.1);"
         "}"
     "}"
   "M=sqrt(M*(1.-length(vec3(0,0,-6)-d)*.05));"
 "}";

#endif // SHADERS_H_
