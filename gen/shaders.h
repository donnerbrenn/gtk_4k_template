// Generated with Shader Minifier 1.3.5 (https://github.com/laurentlb/Shader_Minifier/)
#ifndef SHADERS_H_
# define SHADERS_H_

const char *vshader_vert =
 "#version 400\n"
 "void main()"
 "{"
   "gl_Position=vec4(gl_VertexID%2*2-1,gl_VertexID/2*2-1,1,1);"
 "}";

const char *shader_frag =
 "#version 400\n"
 "const float f=acos(-1)*2;"
 "out vec4 fragColor;\n"
 "#define threshold.001\n"
 "uint m=uint(gl_FragCoord.x*gl_FragCoord.y);"
 "uint t(inout uint v)"
 "{"
   "v=uint(v^uint(61))^uint(v>>uint(16));"
   "v*=uint(9);"
   "v^=v>>4;"
   "v*=uint(668265261);"
   "v^=v>>15;"
   "return v;"
 "}"
 "float v(inout uint v)"
 "{"
   "return float(t(v))/4294967296.;"
 "}"
 "vec3 n(inout uint m)"
 "{"
   "float u=v(m)*2.f-1.f,i=v(m)*f,g=sqrt(1.f-u*u);"
   "return vec3(g*cos(i),g*sin(i),u);"
 "}"
 "float x(vec3 v)"
 "{"
   "return max(max(v.x,v.y),v.z);"
 "}"
 "float n(vec3 v,vec3 m)"
 "{"
   "vec3 i=abs(v)-m;"
   "return length(max(i,vec3(0)))+x(min(i,vec3(0)));"
 "}"
 "float u(vec3 v)"
 "{"
   "float m=n(v,vec3(5,4,100));"
   "return min(-m,length(v)-1);"
 "}"
 "vec3 e(vec3 v)"
 "{"
   "mat3 m=mat3(v,v,v)-mat3(.005);"
   "return normalize(u(v)-vec3(u(m[0]),u(m[1]),u(m[2])));"
 "}"
 "bool e(inout vec3 v,vec3 m)"
 "{"
   "float f=1;"
   "for(uint r=0;r<512&&f>threshold;r++)"
     "v+=m*f,f=u(v);"
   "return f<threshold;"
 "}"
 "void main()"
 "{"
   "vec2 v=(gl_FragCoord.xy/vec2(2560,1440)*2-1)/vec2(1,2560./1440.);"
   "fragColor.xyz=vec3(0);"
   "vec3 i;"
   "for(int f=0;f<300;f++)"
     "{"
       "vec3 u=normalize(vec3(v,1)),g=vec3(0,0,-6);"
       "for(int r=0;r<8&&e(g,u);r++)"
         "{"
           "i=e(g);"
           "fragColor.xyz+=vec3(max(dot(normalize(vec3(0,1,-1)),i),0));"
           "fragColor.xyz+=vec3(max(dot(normalize(vec3(-1,0,1)),i),0));"
           "fragColor.xyz+=vec3(max(dot(-u,i),0));"
           "u=reflect(i,u);"
           "if(r==0)"
             "u=normalize(i+n(m));"
         "}"
     "}"
   "fragColor.xyz=sqrt(fragColor.xyz/2400);"
 "}";

#endif // SHADERS_H_
